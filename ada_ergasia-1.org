#+TITLE: Ανάλυση και σχεδιασμός αλγορίθμων
#+SUBTITLE:  Εργασία 1 - Ομάδα 58
#+DESCRIPTION: Η πρώτη εργασία στο μάθημα της ανάλυσης και σχεδιασμού αλγορίθμων.
#+AUTHOR: Χατζηιωάννου Λαμπρινός, Ευαγγελίδης Νικόλαος, Φιλιππίδης Φοίβος-Παναγιώτης
#+LANGUAGE: el
#+DATE: 2023-04-05
#+KEYWORDS:  algorithms ada
#+latex_class_options: [a4paper,11pt]
#+latex_compiler: xelatex
#+latex_header: \input{sample.tex}


* Πρόβλημα 1                                                       :noexport:

** Εισαγωγικές συμβάσεις
*** Data-matrix
Στο πλαίσιο της εξέτασης του προβλήματος, καθώς δεν δίνεται ο τύπος με τον οποίο
λαμβάνουμε τα δεδομένα, θα θεωρήσουμε ότι τα δεδομένα, για λόγους απλότητας
έρχονται με την μορφή κλασσικού πίνακα ακεραίων ~data-matrix~, με τα μη αρνητικά
στοιχεία του πίνακα να αποτελούν IDs που αντιστοιχούν σε τοπικά πολιτικά πρόσωπα
ενώ τα αρνητικά στοιχεία συνεπάγονται το τέλος δεδομένων για εκείνη την εκλογική
περιοχή.

Αυτή η σύμβαση γίνεται γιατί στην μορφή του /κλασσικού/ πίνακα $k\times l$ όπου
- $k$ το μέγιστο πλήθος των δειγμάτων (πολιτών που ρωτήθηκαν) μεταξύ όλων των περιοχών
- $l$ το πλήθος των περιοχών
Το πλήθος τον δειγμάτων δεν είναι ίδιο σε κάθε περιοχή. Επομένως θα υπάρχουν
κοινά στοιχεία στο τέλος ορισμένων γραμμών, τα οποία δεν θα έχουν σημασία για
τις μετρήσεις μας.

Σε μια μορφή /παραδείγματος/:
\begin{align*}
\begin{bmatrix}
\cdots & \cdots & \cdots & \cdots & \cdots &\cdots & \cdots & \cdots & \cdots \\
0  & 64 & 64 & 32 & 12 & \cdots & \cdots & \cdots & 21 \\
\cdots & \cdots & \cdots & \cdots & \cdots &\cdots & \cdots & \cdots & \cdots \\
0  & 54 & 12 & 22 & 13 & \cdots & -2 & \cdots & \cdots \\
\cdots & \cdots & \cdots & \cdots & \cdots &\cdots & \cdots & \cdots & \cdots \\
\end{bmatrix}
\end{align*}

Στην δεύτερη γραμμή φαίνεται ότι $\text{sample size} = k$ και επομένως οι
αριθμοί συνεχίζουν (με μη αρνητική τιμή μέχρι το τέλος). Στην τέταρτη, όμως,
γραμμή το $-2$ φανερώνει πως τα δεδομένα που συλλέχθηκαν τελειώνουν στην
προηγούμενη στήλη, επιτρέποντας μας να πάμε κατευθείαν στην επόμενη γραμμή. Αυτό
αν και παρουσιάζει μία μικρή βελτίωση στην ταχύτητα του προγράμματος μας,
αποσκοπεί κυρίως στην μη προσπέλαση άχρηστων σε εμάς δεδομένων.

*** Polling-vector
Την ίδια στιγμή, θα αποθηκεύουμε τα δεδομένα μας σε ένα διάνυσμα ~polling-vector~
όπου ~polling-vector[ID]~ θα είναι οι ψήφοι που έχουν συλλεχθεί κατά την
δημοσκόπηση για τον υποψήφιο με το εκάστοτε ID

*** TODO Province Vector

*** Πλήθος υποψηφίων
Χωρίς βλάβη της γενικότητας μπορούμε να περιορίσουμε το πλήθος των υποψηφίων σε
1000 (δηλαδή θεωρώντας πως δεν θα υπάρξει ID μεγαλύτερο του 999). Προφανώς, αν
κάποια είσοδος απαιτούσε ακόμα μεγαλύτερο πλήθος υποψηφίων αυτό δεν θα επηρέαζε
καθόλου τον αλγόριθμο, μόνο θα απαιτούσε κατάλληλη αλλαγή του κώδικα.

*** Συναρτήσεις ελέγχου εντός του κώδικα
Μέσα στον κώδικα θα δείτε ορισμένες συναρτήσεις οι οποίες ορίστηκαν κυρίως για
τον έλεγχο της λογικής και λειτουργίας του αλγορίθμου. Αν και εύκολα κατανοητές
και /self-described/, κρίναμε καλό το να τις αφήσουμε εδώ για την αποφυγή της
οποιας παρεξήγησης.

**** printNonNilCandidates
Πολύ απλή συνάρτηση, πολυπλοκότητας $O(n)$, όπου $n$ το μήκος του διανύσματος
εισόδου ~myvector~. Ο ρόλος της είναι απλά να τυπώνει τις ψήφους όλων εκείνων που
συγκέντρωσαν τουλάχιστον μια ψήφο.

#+begin_src python
def printNonNilCandidates(myvector):
    "Simply iterate through the vector and print candidates that got at least one vote"
    for i in range(len(myvector)):
        if myvector[i] > 0:
            print(f"Candidate {i}:\t {myvector[i]}")
#+end_src

**** candidateWinsTheProvince
Εξίσου απλή συνάρτηση, πολυπλοκότητας και πάλι $O(n)$, όπου $n$ το μήκος του
διανύσματος εισόδου ~myvector~, η οποία βοηθά στον έλεγχο του κατα πόσο κάποιος
κέρδισε την εκάστοτε εκλογική περιφέρεια.

#+begin_src python
def printNonNilCandidates(myvector):
    "Simply iterate through the vector and print candidates that got at least one vote"
    for i in range(len(myvector)):
        if myvector[i] > 0:
            print(f"Candidate {i}:\t {myvector[i]}")
#+end_src

*** Μεταβλητή εισόδου: ~data_matrix~
Ουσιαστικά είναι η μεταβλητή που αλλάζει...

Περίπτωση απλή
#+begin_src pyton
data_matrix = [[12, 12, 52],
               [13, 2, 15],
               [12, 51, 2]]
#+end_src

Γενικά καλύτερη περίπτωση
#+begin_src pyton
data_matrix = [[12, -12, 52],
               [13, 2, 15],
               [12, 51, -2]]
#+end_src

*** Μορφή εξόδου
Ο αλγόριθμος μας είναι σχεδιασμένος να επιστρέφει ένα boolean vector, με μήκος
ίσο με το πλήθος των γραμμών του ~data_matrix~. Θετική τιμή σε κάποιο στοιχείο της
εξόδου σημαίνει πως υπάρχει πολιτικός, στην περιοχή που αντιστοιχεί εκείνη η
γραμμή, που συγκεντρώνει πάνω από το 50% των ψήφων.

** Αλγόριθμος πολυπλοκότητας $O(n^2)$
Ο αρχικός αλγόριθμος είναι αυτός που έρχεται φυσικά σε όποιον ακούσει το
πρόβλημα και δεν προϋποθέτει καμία ενέργεια επεξεργασίας των δεδομένων εισόδου:

#+begin_example
0. Για κάθε περιοχή: έγκυρη_περιοχή[εξεταζόμενη περιοχή] = Ψευδές
1. Για κάθε περιοχή:
2.     Για κάθε δείγμα που λήφθηκε για αυτή την περιοχή:
3.         Αν εξεταζόμενο δείγμα < 0:
4.             Δεν υπάρχουν άλλα δείγματα για αυτή την περιοχή, τελος εσωτερικού βρόχου επανάληψης
5.         ψήφοι[επιλογή του εξεταζόμενου δείγματος] += 1
6.     Για κάθε πιθανό υποψήφιο:
7.         Αν ψήφοι[υποψηφίου] > μισών ψήφων:
8.             εγκυρη_περιοχή[εξεταζόμενη περιοχή] = Αληθές
9.             Τέλος βρόχου
#+end_example


Όπως φανερώνει και ο αλγόριθμος σε ψευδογλώσσα, σε big O notation, η
πολυπλοκότητα του αλγορίθμου μπορεί αρχικά να εκφραστεί ως:
\begin{equation}
O(\text{number of areas}\times\text{number of samples per area} + \text{number of areas}\times\text{number of candidates})
\end{equation}

Θέτοντας ως άνω φράγμα για αυτές τις ποσότητες το $n$, δηλαδή να ισχύει:
\begin{equation}
\text{number of areas}, \text{number of samples per area}, \text{number of candidates} \leq n
\end{equation}

Καθίσταται προφανές ότι η πολυπλοκότητα του κώδικα είναι $O(n^2)$

Παρακάτω δίνεται ο κώδικας του παραπάνω αλγορίθμου σε python
#+begin_src python

def o_squared_complexity_algorithm():
    "First solution, non-optimized, to the given problem"
    number_of_provinces = len(data_matrix)
    province_vector = [0] * number_of_provinces
    for electional_province in range(number_of_provinces):
        # This should be a rather logical assumption for the working circumstances
        candidate_votes_vector = [0] * 1000
        # This variable is useful to determine
        stop_point = len(data_matrix[electional_province])
        # For every column (point of data at that time)
        for data_point_index in range(stop_point):
            # Agreed upon hypothesis: Valid IDs need to be non-negative
            if data_matrix[electional_province][data_point_index] < 0:
                stop_point = data_point_index
                break
            candidate_votes_vector[data_matrix[electional_province][data_point_index]] += 1
        province_vector[electional_province] = candidatewinstheprovince(candidate_votes_vector, stop_point)
        if province_vector[electional_province]:
            print(f"Someone wins province {electional_province}")
#+end_src

** Βελτιωμένος αλγόριθμος πολυπλοκότητας $O(n\log{n})$
Για να βελτιώσουμε τον αλγόριθμο, έχοντας βοήθεια και από την εκφώνηση όσον
αφορά την Divide and Conquer φύση της λύσης με πολυπλοκότητα $O(n\log{n})$, αυτό
που μπορούμε να κάνουμε είναι:

#+begin_example
πλήθος_περιοχών = μήκος(πίνακα εισόδου)
αν πλήθος_περιοχών == 1:
    Για κάθε στοιχείο της γραμμής του πίνακα εισόδου:
        Αν αρνητικό:
           Τέλος του βρόχου επανάληψης
        ψήφοι[τιμή εξεταζόμενου στοιχείου] += 1
    Για κάθε πιθανό υποψήφιο:
        Αν ψήφοι[εξεταζόμενου υποψηφίου] > πλήθος δειγμάτων περιοχής // 2
        έξοδος[εξεταζόμενη περιοχή] = Αληθής

πάνω_πίνακας = οι πρώτες πλήθος_περιοχών // 2 σειρές του πίνακα εισόδου (ακέραια διαίρεση)
κάτω_πίνακας = οι σειρές μέτα από την πλήθος_περιοχών // 2.

Πάνε στο βήμα 1, με είσοδο τον πάνω_πίνακας
Πάνε στο βήμα 1, με είσοδο τον κάτω_πίνακας
#+end_example
TODO: Μαθηματική ανάλυση.
Γενικά καταλήγεις στο:
\begin{equation}
T(n) = T(n/2) + O(n)
\end{equation}
το οποίο είναι ενδεικτικό του $O(n\log{n})$, αλλά δεν παίρνω όρκο. Δες το και αν
έχεις καμία καλύτερη ιδέα πυροβόλα.

Γραμμένος σε python
TODO: Είναι προβληματικός κώδικας εδώ: Δεν επιστρέφει έξοδο της κατάλληλης μορφής.
#+begin_src python
def divide_and_conquer_algorithm(data_matrix):
    "Divide and conquer solution to the given problem"
    number_of_provinces = len(data_matrix)
    if number_of_provinces == 1:
        candidate_votes_vector = [0] * 1000
        stop_point = len(data_matrix[0])
        for data_point_index in range(stop_point):
            if data_matrix[0][data_point_index] < 0:
                stop_point = data_point_index
                break
            candidate_votes_vector[data_matrix[0][data_point_index]] += 1
        return candidatewinstheprovince(candidate_votes_vector, stop_point)

    top_matrix = data_matrix[:number_of_provinces//2]
    bottom_matrix = data_matrix[number_of_provinces//2:]

    top_result = divide_and_conquer_algorithm(top_matrix)
    bottom_result = divide_and_conquer_algorithm(bottom_matrix)

    return left_result + right_result
#+end_src


** TODO Εξέταση ύπαρξης αλγορίθμου $O(n)$
θα έλεγα οτι δεν μπορεί να υπάρξει, καθώς είναι απαραίτητη η προσπέλαση των
στοιχείων, αλλά πάλι το $O(n\log{n})$ υπήρξε οπότε ...? 


* Πρόβλημα 1
Σκοπεύετε να βάλετε υποψηφιότητα στις επερχόμενες εκλογές και επιθυμείτε να
οργανώσετε όσο το δυνατό πιο αποτελεσματικά τις περιοδείες σας.

Εχετε στα χέρια σας δημοσκοπικά δεδομένα τα οποία σας δίνουν πληροφορία για κάθε
χωριό και πόλη της περιφέρειας στην οποία θέτετε υποψηφιότητα. Συγκεκριμένα για
κάθε ένα από τα μέρη αυτά, έχετε στα χέρια σας τί δήλωσε κάθε πολίτης, που πήρε
μέρος σε δημοσκόπηση, οτι προτίθεται να ψηφίσει (το ονοματεπώνυμο των υποψηφίων,
εσάς και των αντιπάλων σας).

Επειδή τα χρονικά περιθώρια είναι πολύ στενά, επιθυμείτε να περιοδεύσετε μόνο
στα μέρη εκείνα τα οποία φαίνεται από τα δημοσκοπικά δεδομένα ότι δεν
συγκεντρώνετε τουλάχιστον τις μισές ψήφους.

1. Σχεδιάστε έναν αλγόριθμο ο οποίος θα αποφασίζει για ένα μέρος σε χρόνο $O(n^2)$
2. Χρησιμοποιήστε την τεχνική Διαίρει και Βασίλευε για να επιτύχετε το παραπάνω
   σε χρόνο O(n log n).
3. Υπάρχει αλγόριθμος που να επιτυγχάνει την ίδια εργασία σε χρόνο O(n);

*** Συμβάσεις στην χρήση των μεταβλητών
Στους αλγορίθμους του πρώτου προβλήματος (και τις αναλύσεις τους) θα δείτε την
χρήση μεταβλητών όπως:
- $n$, που αντιστοιχεί στο μήκος της λίστας εισόδου
- $k$, που αντιστοιχεί στο πλήθος υποψήφιων στις εκάστοτε εκλογές
  
*** Συμβάσεις στην φύση του προβλήματος
Καθώς προσδιορίστηκε πως η ισότητα ελέγχου γραμματοσειρών είναι εκτός του
ενδιαφέροντος της εργασίας, θεωρήσαμε είσοδο της μορφής:

\begin{equation}
\label{eq:3}
\text{input array} = 
\begin{bmatrix}
\text{int} &
\text{int} &
\text{int} &
\text{int} &
\text{int} &
\text{int} &
\text{int} & \cdots
\end{bmatrix}
\end{equation}

όπου ο κάθε ακέραιος είναι μοναδικό ID το οποίο αντιστοιχεί (ένα προς ένα) σε
υποψήφιο της εκάστοτε περιοχής. Έτσι, όταν αναφερόμαστε στον /υποψήφιο/, δεν
αναφερόμαστε ονομαστικά σε εκείνο, αλλά στον αριθμό που του αντιστοιχεί.

Το 0 είναι μή αποδεκτό ID, και για λόγους αποδοτικότητας μνήμης (όπως αυτό
καθίσταται εμφανές στο τρίτο υποερώτημα), θεωρούμε πως σε κάθε περίπτωση τα ID
που έχουν αποδοθεί στα πολιτικά πρόσωπα είναι συνεχόμενα.

** Υποερωτήμα πρώτο
Γνωρίζουμε ήδη οτι προκειμένου να έχει πολυπλοκότητα ο αλγόριθμος της ταξης του
$O(n^2)$ θα πρέπει να έχουμε /ενσωματωμένες/ επαναλήψεις.

Όπως φαίνεται στον παρακάτω κώδικα, αξιοποιούμε 2 ~for~. Λεκτικά, αυτά μπορούν να
περιγραφούν ως εξής:

Για κάθε υποψήφιο στις εκλογές (εξωτερικό loop), μέτρα όλες τις ψήφους που έχει
λάβει. Αν εκείνες είναι μεγαλύτερες από τις μισές ψήφους που καταμετρήθηκαν για
την περιοχή, τότε το ζητούμενο του ερωτήματος είναι αληθές.

#+begin_example
1. Ζήτημα_Ερωτήματος = Ψευδές
2. Για i = 0, ... , k-1:
3.     counter = 0
4.     Για j = 0, ... , n-1:
5. 		Εάν i == ψήφοι[j]:
6.                     counter += 1
7.             Εάν counter > n/2 :
8.                     Ζήτημα_Ερωτήματος = Αληθές
9. Επίστρεψε Ζήτημα_Ερωτήματος
#+end_example


Στην ανάλυση του παραπάνω αλγορίθμου βλέπουμε ότι:
- Το πρώτο for εκτελείται $k$ φορές. Αν λάβουμε υπόψιν μας την χειρότερη
  περίπτωση[fn:1], δηλαδή να έχουμε τους μέγιστους υποψήφιους, τότε πρακτικά μιλάμε
  για $n$ διαφορετικούς υποψηφίους.
- Το ενωματωμένο (nested) for loop, καθώς αποτελείται από πράξεις σταθερού
  χρόνου $O(1)$, και επαναλαμβάνεται $n$ φορές έχει πολυπλοκότητα $O(n)$

Έτσι, η πολυπλοκότητα, συνολικά του αλγορίθμου:
\begin{equation}
\label{eq:2}
O(k*n) \stackrel{k\leq n}{=} O(n^{2})
\end{equation}


** Υποερωτήμα δεύτερο
Για να χτίσουμε αλγόριθμο πολυπλοκότητας $O(n\log{n})$, είναι προφανές πως η divide
and conquer λύση μας θα βασίζεται στην διαίρεση των δεδομένων εισόδου, και την
αναδρομική λειτουργία επί των .


*** Συνάρτηση πλειοψηφία
Η γενική συνάρτηση που θα εκμεταλλευτούμε είναι η ~πλειοψηφία~, η οποία δεδομένων
δεικτών αριστερού και δεξιού άκρου εντός της λίστας εισόδου ~ψήφοι~, επιστρέφει
την τιμή του πλειοψηφικού στοιχείου της, αν αυτό υπάρχει. Αν δεν υπάρχει τότε
επιστρέφει 0 (ψευδές).

Το παραπάνω βασίζεται στο, αποδείξιμο, γεγονός ότι για να είναι ένα στοιχείο
πλειοψηφικό μίας λίστας, χρειάζεται να είναι το πλειοψηφικό είτε του δεξιού είτε
του αριστερού μισού της.


#+begin_example
Συνάρτηση πλειοψηφία(αριστερά, δεξιά, ψήφοι):

    // Αν μόνο ενα στοιχείο εντός της λίστας τότε
    // είναι το πλειοψηφικό στοιχείο της.
    Εάν αριστερά == δεξιά:
        επίστρεψε ψήφοι[δεξιά]

    // Μοίρασε την λίστα στην μέση, και κατόπιν αναδρομικά
    // εξέτασε το δεξί και το αριστερό κομμάτι.
    μέση                = (αριστερά + δεξιά) // 2
    αριστερή_πλειοψηφία = πλειοψηφία(αριστερά, μέση, ψήφοι)
    δεξί_πλειοψηφία     = πλειοψηφία(μέση+1, δεξιά, ψήφοι)

    // Εάν πλειοψηφία και κοινός υποψήφιος σε πλειοψηφία
    Εάν αριστερή_πλειοψηφία == δεξιά_πλειοψηφία:
       επίστρεψε αριστερή_πλειοψηφία

    // Εάν υπάρχει πλειοψηφία στο αριστερό μισό
    Εάν αριστερή_πλειοψηφία:
        επαναλήψεις = 0.
        Για j = αριστερά ,,, δεξιά:
           Αν ψήφοι[j] == αριστερη_πλειοψηφία:
              επαναλήψεις += 1.
        Αν επαναλήψεις > (δεξιά - αριστερά) // 2:
           επίστρεψε αριστερή_πλειοψηφία

    // Αντίστοιχα, για πλειοψηφία στο δεξί μισό
    Εάν δεξιά_πλειοψηφία:
        επαναλήψεις = 0.
        Για j = αριστερά ,,, δεξιά:
           Αν ψήφοι[j] == δεξιά_πλειοψηφία
              επαναλήψεις += 1.
        Αν επαναλήψεις > (δεξιά - αριστερά) // 2:
           επίστρεψε δεξιά_πλειοψηφία

    Επίστρεψε 0
#+end_example


*** Ανάλυση και επαλήθευση
Η εγκυρότητα της παραπάνω συνάρτησης/αλγορίθμου, επαληθεύεται με την μέθοδο της
επαγωγής. Για την χρονική πολυπλοκότητα της έχουμε:

\begin{equation}
\label{eq:4}
T(n) = T(n/2) + O(n)
\end{equation}

Χαρακτηριστική επίλυσης τύπου DC, η οποία για $n\to\infty$ ξέρουμε ότι
συνεπάγεται πολυπλοκότητα $O(n\log{n})$.

*** Τελική μορφή αλγόριθμου
Έτσι, αν θεωρήσουμε για λόγους συνέπειας πως θέλουμε το πρόγραμμα μας να
επιστρέφει Αληθή ή Ψευδή τιμή βάση της ύπαρξης πλειοψηφίας στο εξεταζόμενο
μέρος, ο τελικός αλγόριθμος είναι ο εξής:
#+begin_example
1. Αν πλειοψηφία(0, n-1, ψήφοι)
2.     Ζήτημα_Ερωτήματος = Αληθές
3. Αλλιώς
4.     Ψευδές
#+end_example


** Υποερωτήμα τρίτο
Υπάρχει γραμμικός αλγόριθμος, τον οποίο και παραθέτουμε παρακάτω.
Εκμεταλλευόμενοι την έλλειψη περιορισμού στην μνήμη, κατασκευάζουμε μία λίστα $X$,
μήκους $k$, ώστε να χωράει τον αριθμό ψήφων του κάθε υποψηφίου, και ελέγχουμε
ένα ένα τα στοιχεία της λίστα εισόδου ~ψήφοι~, ενημερώνοντας κατάλληλα την $X$.

Σε κάθε βήμα ελέγχουμε αν το ενημερωμένο στοιχείο της $X$ πληρεί τις
προϋποθέσεις πλειοψηφίας, για την επιστροφή αληθούς τιμής.

#+begin_example
1. Ζήτημα_Ερωτήματος = Ψευδές
2. Για i = 0, ... , k-1:	
3.     Χ[i] = 0
4. Για i = 0, ... , n-1:
5.     X[ψήφοι[i]] += 1
6.     Εάν X[ψήφοι[i]] > n/2:
7.         Ζήτημα_Ερωτήματος = Αληθές
#+end_example

* Πρόβλημα 2

Ο κώδικας που δόθηκε είναι της μορφής. 

Algorithm 1
#+begin_example
1. for i = 0,...,k do
2.     H[i] = 0
3. end for
4. for j = 1,...,n do
5.     H[T[j]] = H[T[j]] + 1
6. end for
7. for i = 1,...,k do
8.     H[i] = H[i] + H[i − 1]
9. end for
10. for j = n,...,1 do
11.     S[H[T [j]]] = T [j]
12.     H[T[j]] = H[T[j]] − 1
13. end for
#+end_example

** Έκδοση σε python                                               :noexport:
Δωράκι σε python (θα βγει πριν την υποβολή):
#+begin_src python
# Counting sort

def second_algorithm(T, k):
    n = len(T)
    H = [0] * k
    S = [0] * n

    # Count the number of occurrences of each integer in T
    for j in range(n):
        H[T[j] - 1] += 1

    # Compute the cumulative sum of H
    for i in range(1, k):
        H[i] += H[i - 1]

    # Place each element of T in the correct position in S
    for j in range(n - 1, -1, -1):
        S[H[T[j] - 1] - 1] = T[j]
        H[T[j] - 1] -= 1

    return S
#+end_src
** Περιγραφή του αλγορίθμου
Ο δοθείς αλγόριθμος είναι μια παραλλαγή του counting sort, αλγόριθμου με
πολυπλοκότητα $O(n+k)$, χρήσιμου, όμως, μόνο όταν γνωρίζουμε το $k$ (μέγιστη
πιθανή τιμή των στοιχείων εντός του πίνακα) και εκείνο είναι επαρκώς μικρό, ώστε
να μπορούμε να δεσμέυσουμε αρκετά μεγάλο χώρο για την λίστα $H$.

Έχουμε
1. Πρώτο loop, block complexity $O(k)$:
   Αρχικοποίηση του πίνακα $H$, ούτως ώστε όλα του τα στοιχεία να είναι μηδενικά
2. Δεύτερο loop, block complexity $O(n)$:
   Ουσιαστικά διαμόρφωση του πίνακα $H$ ούτως ώστε το στοιχείο $H[n]$ να μας
   δείχνει πόσες φορές υπήρξε το $n$ στον πίνακα εισόδου $T$
3. Τρίτο loop, block complexity $O(k)$:
   Διαμόρφωση του πίνακα $H$ ούτως ώστε το $H[n]$, να μας δείχνει το πλήθος των
   στοιχείων τιμής μικρότερης η ίσης του $n$ υπήρξε στον πίνακα εισόδου $T$
4. Τέταρτο loop, block complexity $O(n)$: Εισαγωγή του πίνακα $S$: Για κάθε
   στοιχείο του αρχικού πίνακα $T$, χρησιμοποιούμε τον πίνακα $H$ και το
   τοποθετούμε στην κατάλληλη θέση. Αναλυτικότερα, γνωρίζοντας από το $H$ πόσα
   στοιχεία βρίσκονται πριν από αυτό στην ταξινομιμένη εκδοχή του πίνακα, το
   βάζουμε στην μέγιστη θέση που μπορεί να μπεί, ενώ παράλληλα μειώνουμε το κελί
   του $H$ που αντιστοιχεί στην υπο εξέταση τιμή, ώστε τυχόν επαναλήψεις του να
   μπουν πριν από εκείνο. Έτσι τελικά, ο $S$ είναι ο $T$ με τα στοιχεία του σε
   αύξουσα σειρά.

** Ανάλυση του αλγορίθμου
Ο αλγόριθμος αποτελείται από μία σειρά δομών επανάληψης, χωρίς καμία να είναι
ενσωματωμένη σε άλλη. Η πολυπλοκότητα κάθε μίας εξ αυτών, καθώς περιλαμβάνει μόνο απλές
πράξεις (πολυπλοκότητας $O(1)$) εύκολα φαίνεται ότι είναι:
- $O(k)$
- $O(n)$
- $O(k)$
- $O(n)$

Έτσι, συνολικά ο αλγόριθμος έχει πολυπλοκότητα $O(n+k)$

* Footnotes

[fn:1] Κατόπιν διευκρίνησης που δόθηκε ότι $k\leq n$ 
