#+TITLE: Ανάλυση και σχεδιασμός αλγορίθμων
#+SUBTITLE:  Εργασία 1
#+DESCRIPTION: Η πρώτη εργασία στο μάθημα της ανάλυσης και σχεδιασμού αλγορίθμων.
#+AUTHOR: Χατζηιωάννου Λαμπρινός, Ευαγγελίδης Νικόλαος, Φιλιππίδης Φοίβος-Παναγιώτης
#+LANGUAGE: el
#+DATE: <2023-04-05 Wed>
#+KEYWORDS:  algorithms ada
#+latex_class_options: [a4paper,11pt]
#+latex_compiler: xelatex
#+latex_header: \input{~/Github/org-to-latex-export/sample.tex}


* Πρόβλημα 1
#+begin_comment
Σκοπεύετε να βάλετε υποψηφιότητα στις επερχόμενες εκλογές και επιθυμείτε να
οργανώσετε όσο το δυνατό πιο αποτελεσματικά τις περιοδείες σας.

Εχετε στα χέρια σας δημοσκοπικά δεδομένα τα οποία σας δίνουν πληροφορία για κάθε
χωριό και πόλη της περιφέρειας στην οποία θέτετε υποψηφιότητα. Συγκεκριμένα για
κάθε ένα από τα μέρη αυτά, έχετε στα χέρια σας τί δήλωσε κάθε πολίτης, που πήρε
μέρος σε δημοσκόπηση, οτι προτίθεται να ψηφίσει (το ονοματεπώνυμο των υποψηφίων,
εσάς και των αντιπάλων σας).

Επειδή τα χρονικά περιθώρια είναι πολύ στενά, επιθυμείτε να περιοδεύσετε μόνο
στα μέρη εκείνα τα οποία φαίνεται από τα δημοσκοπικά δεδομένα ότι δεν
συγκεντρώνετε τουλάχιστον τις μισές ψήφους.

1. Σχεδιάστε έναν αλγόριθμο ο οποίος θα αποφασίζει για ένα μέρος σε χρόνο $0(n^2)$

2. Χρησιμοποιήστε την τεχνική Διαίρει και Βασίλευε για να επιτύχετε το παραπάνω
σε χρόνο O(n log n).

3. Υπάρχει αλγόριθμος που να επιτυγχάνει την ίδια εργασία σε χρόνο O(n);

#+end_comment

** Εισαγωγικές συμβάσεις
*** Data-matrix
Στο πλαίσιο της εξέτασης του προβλήματος, καθώς δεν δίνεται ο τύπος με τον οποίο
λαμβάνουμε τα δεδομένα, θα θεωρήσουμε ότι τα δεδομένα, για λόγους απλότητας
έρχονται με την μορφή κλασσικού πίνακα ακεραίων ~data-matrix~, με τα μη αρνητικά
στοιχεία του πίνακα να αποτελούν IDs που αντιστοιχούν σε τοπικά πολιτικά πρόσωπα
ενώ τα αρνητικά στοιχεία συνεπάγονται το τέλος δεδομένων για εκείνη την εκλογική
περιοχή.

Αυτή η σύμβαση γίνεται γιατί στην μορφή του /κλασσικού/ πίνακα $k\times l$ όπου
- $k$ το μέγιστο πλήθος των δειγμάτων (πολιτών που ρωτήθηκαν) μεταξύ όλων των περιοχών
- $l$ το πλήθος των περιοχών
Το πλήθος τον δειγμάτων δεν είναι ίδιο σε κάθε περιοχή. Επομένως θα υπάρχουν
κοινά στοιχεία στο τέλος ορισμένων γραμμών, τα οποία δεν θα έχουν σημασία για
τις μετρήσεις μας.

Σε μια μορφή /παραδείγματος/:
\begin{align*}
\begin{bmatrix}
\cdots & \cdots & \cdots & \cdots & \cdots &\cdots & \cdots & \cdots & \cdots \\
0  & 64 & 64 & 32 & 12 & \cdots & \cdots & \cdots & 21 \\
\cdots & \cdots & \cdots & \cdots & \cdots &\cdots & \cdots & \cdots & \cdots \\
0  & 54 & 12 & 22 & 13 & \cdots & -2 & \cdots & \cdots \\
\cdots & \cdots & \cdots & \cdots & \cdots &\cdots & \cdots & \cdots & \cdots \\
\end{bmatrix}
\end{align*}

Στην δεύτερη γραμμή φαίνεται ότι $\text{sample size} = k$ και επομένως οι
αριθμοί συνεχίζουν (με μη αρνητική τιμή μέχρι το τέλος). Στην τέταρτη, όμως,
γραμμή το $-2$ φανερώνει πως τα δεδομένα που συλλέχθηκαν τελειώνουν στην
προηγούμενη στήλη, επιτρέποντας μας να πάμε κατευθείαν στην επόμενη γραμμή. Αυτό
αν και παρουσιάζει μία μικρή βελτίωση στην ταχύτητα του προγράμματος μας,
αποσκοπεί κυρίως στην μη προσπέλαση άχρηστων σε εμάς δεδομένων.

*** Polling-vector
Την ίδια στιγμή, θα αποθηκεύουμε τα δεδομένα μας σε ένα διάνυσμα ~polling-vector~
όπου ~polling-vector[ID]~ θα είναι οι ψήφοι που έχουν συλλεχθεί κατά την
δημοσκόπηση για τον υποψήφιο με το εκάστοτε ID

*** TODO Province Vector

*** Πλήθος υποψηφίων
Χωρίς βλάβη της γενικότητας μπορούμε να περιορίσουμε το πλήθος των υποψηφίων σε
1000 (δηλαδή θεωρώντας πως δεν θα υπάρξει ID μεγαλύτερο του 999). Προφανώς, αν
κάποια είσοδος απαιτούσε ακόμα μεγαλύτερο πλήθος υποψηφίων αυτό δεν θα επηρέαζε
καθόλου τον αλγόριθμο, μόνο θα απαιτούσε κατάλληλη αλλαγή του κώδικα.

*** Συναρτήσεις ελέγχου εντός του κώδικα
Μέσα στον κώδικα θα δείτε ορισμένες συναρτήσεις οι οποίες ορίστηκαν κυρίως για
τον έλεγχο της λογικής και λειτουργίας του αλγορίθμου. Αν και εύκολα κατανοητές
και /self-described/, κρίναμε καλό το να τις αφήσουμε εδώ για την αποφυγή της
οποιας παρεξήγησης.

**** printNonNilCandidates
Πολύ απλή συνάρτηση, πολυπλοκότητας $O(n)$, όπου $n$ το μήκος του διανύσματος
εισόδου ~myvector~. Ο ρόλος της είναι απλά να τυπώνει τις ψήφους όλων εκείνων που
συγκέντρωσαν τουλάχιστον μια ψήφο.

#+begin_src python
def printNonNilCandidates(myvector):
    "Simply iterate through the vector and print candidates that got at least one vote"
    for i in range(len(myvector)):
        if myvector[i] > 0:
            print(f"Candidate {i}:\t {myvector[i]}")
#+end_src

**** candidateWinsTheProvince
Εξίσου απλή συνάρτηση, πολυπλοκότητας και πάλι $O(n)$, όπου $n$ το μήκος του
διανύσματος εισόδου ~myvector~, η οποία βοηθά στον έλεγχο του κατα πόσο κάποιος
κέρδισε την εκάστοτε εκλογική περιφέρεια.

#+begin_src python
def printNonNilCandidates(myvector):
    "Simply iterate through the vector and print candidates that got at least one vote"
    for i in range(len(myvector)):
        if myvector[i] > 0:
            print(f"Candidate {i}:\t {myvector[i]}")
#+end_src

*** Μεταβλητή εισόδου: ~data_matrix~
Ουσιαστικά είναι η μεταβλητή που αλλάζει...

Περίπτωση απλή
#+begin_src pyton
data_matrix = [[12, 12, 52],
               [13, 2, 15],
               [12, 51, 2]]
#+end_src

Γενικά καλύτερη περίπτωση
#+begin_src pyton
data_matrix = [[12, -12, 52],
               [13, 2, 15],
               [12, 51, -2]]
#+end_src

*** Μορφή εξόδου
Ο αλγόριθμος μας είναι σχεδιασμένος να επιστρέφει ένα boolean vector, με μήκος
ίσο με το πλήθος των γραμμών του ~data_matrix~. Θετική τιμή σε κάποιο στοιχείο της
εξόδου σημαίνει πως υπάρχει πολιτικός, στην περιοχή που αντιστοιχεί εκείνη η
γραμμή, που συγκεντρώνει πάνω από το 50% των ψήφων.

** Αλγόριθμος πολυπλοκότητας $O(n^2)$
Ο αρχικός αλγόριθμος είναι αυτός που έρχεται φυσικά σε όποιον ακούσει το
πρόβλημα και δεν προϋποθέτει καμία ενέργεια επεξεργασίας των δεδομένων εισόδου:

#+begin_example
0. Για κάθε περιοχή: έγκυρη_περιοχή[εξεταζόμενη περιοχή] = Ψευδές
1. Για κάθε περιοχή:
2.     Για κάθε δείγμα που λήφθηκε για αυτή την περιοχή:
3.         Αν εξεταζόμενο δείγμα < 0:
4.             Δεν υπάρχουν άλλα δείγματα για αυτή την περιοχή, τελος εσωτερικού βρόχου επανάληψης
5.         ψήφοι[επιλογή του εξεταζόμενου δείγματος] += 1
6.     Για κάθε πιθανό υποψήφιο:
7.         Αν ψήφοι[υποψηφίου] > μισών ψήφων:
8.             εγκυρη_περιοχή[εξεταζόμενη περιοχή] = Αληθές
9.             Τέλος βρόχου
#+end_example


Όπως φανερώνει και ο αλγόριθμος σε ψευδογλώσσα, σε big O notation, η
πολυπλοκότητα του αλγορίθμου μπορεί αρχικά να εκφραστεί ως:
\begin{equation}
O(\text{number of areas}\times\text{number of samples per area} + \text{number of areas}\times\text{number of candidates})
\end{equation}

Θέτοντας ως άνω φράγμα για αυτές τις ποσότητες το $n$, δηλαδή να ισχύει:
\begin{equation}
\text{number of areas}, \text{number of samples per area}, \text{number of candidates} \leq n
\end{equation}

Καθίσταται προφανές ότι η πολυπλοκότητα του κώδικα είναι $O(n^2)$

Παρακάτω δίνεται ο κώδικας του παραπάνω αλγορίθμου σε python
#+begin_src python

def o_squared_complexity_algorithm():
    "First solution, non-optimized, to the given problem"
    number_of_provinces = len(data_matrix)
    province_vector = [0] * number_of_provinces
    for electional_province in range(number_of_provinces):
        # This should be a rather logical assumption for the working circumstances
        candidate_votes_vector = [0] * 1000
        # This variable is useful to determine
        stop_point = len(data_matrix[electional_province])
        # For every column (point of data at that time)
        for data_point_index in range(stop_point):
            # Agreed upon hypothesis: Valid IDs need to be non-negative
            if data_matrix[electional_province][data_point_index] < 0:
                stop_point = data_point_index
                break
            candidate_votes_vector[data_matrix[electional_province][data_point_index]] += 1
        province_vector[electional_province] = candidatewinstheprovince(candidate_votes_vector, stop_point)
        if province_vector[electional_province]:
            print(f"Someone wins province {electional_province}")
#+end_src

** Βελτιωμένος αλγόριθμος πολυπλοκότητας $O(n\log{n})$
Για να βελτιώσουμε τον αλγόριθμο, έχοντας βοήθεια και από την εκφώνηση όσον
αφορά την Divide and Conquer φύση της λύσης με πολυπλοκότητα $O(n\log{n})$, αυτό
που μπορούμε να κάνουμε είναι:

#+begin_example
πλήθος_περιοχών = μήκος(πίνακα εισόδου)
αν πλήθος_περιοχών == 1:
    Για κάθε στοιχείο της γραμμής του πίνακα εισόδου:
        Αν αρνητικό:
           Τέλος του βρόχου επανάληψης
        ψήφοι[τιμή εξεταζόμενου στοιχείου] += 1
    Για κάθε πιθανό υποψήφιο:
        Αν ψήφοι[εξεταζόμενου υποψηφίου] > πλήθος δειγμάτων περιοχής // 2
        έξοδος[εξεταζόμενη περιοχή] = Αληθής

πάνω_πίνακας = οι πρώτες πλήθος_περιοχών // 2 σειρές του πίνακα εισόδου (ακέραια διαίρεση)
κάτω_πίνακας = οι σειρές μέτα από την πλήθος_περιοχών // 2.

Πάνε στο βήμα 1, με είσοδο τον πάνω_πίνακας
Πάνε στο βήμα 1, με είσοδο τον κάτω_πίνακας
#+end_example

** Εξέταση ύπαρξης αλγορίθμου $O(n)$

* Πρόβλημα 2

Ο κώδικας που δόθηκε είναι της μορφής. 

#+begin_example
Algorithm 1
1. for i = 0,...,k do
2.     H[i] = 0
3. end for
4. for j = 1,...,n do
5.     H[T[j]] = H[T[j]] + 1
6. end for
7. for i = 1,...,k do
8.     H[i] = H[i] + H[i − 1]
9. end for
10. for j = n,...,1 do
11.     S[H[T [j]]] = T [j]
12.     H[T[j]] = H[T[j]] − 1
13. end for
#+end_example

** Περιγραφή του πίνακα $S$
Έχουμε
1. Πρώτο loop, block complexity $O(k)$:
   Αρχικοποίηση του πίνακα $H$, ούτως ώστε όλα του τα στοιχεία να είναι μηδενικά
2. Δεύτερο loop, block complexity $O(n)$:
   Ουσιαστικά διαμόρφωση του πίνακα $H$ ούτως ώστε το στοιχείο $H[n]$ να μας
   δείχνει πόσες φορές υπήρξε το $n$ στον πίνακα εισόδου $T$
3. Τρίτο loop, block complexity $O(k)$:
   Διαμόρφωση του πίνακα $H$ ούτως ώστε το $H[n]$, να μας δείχνει το πλήθος των
   στοιχείων τιμής μικρότερης η ίσης του $n$ υπήρξε στον πίνακα εισόδου $T$
4. Τέταρτο loop, block complexity $O(n)$:
   Εισαγωγή του πίνακα $S$. 

** Ανάλυση του αλγορίθμου


