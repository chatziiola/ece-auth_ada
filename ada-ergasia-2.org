#+TITLE: Μια παράλογη εξέταση του δεύτερου προβλήματος
#+DESCRIPTION: Η δεύτερη εργασία στο μάθημα της ανάλυσης και σχεδιασμού αλγορίθμων.
#+AUTHOR: Χατζηιωάννου Λαμπρινός
#+LANGUAGE: el
#+DATE: 2023-04-05
#+OPTIONS: toc:nil

* Πρόβλημα 2
** Εκφώνηση
Μια αλυσίδα fast food πρόκειται να ανοίξει μια σειρά από εστιατόρια κατά μήκος
της Εγνατίας. Οι $n$ πιθανές τοπο- θεσίες έχουν αποστάσεις από την αρχή της
Εγνατίας σε αύξουσα σειρά $m_1, m_2, \cdots, m_n$ σε μέτρα. Το προσδοκώμενο
κέρδος από το άνοιγμα ενός εστιατορίου στην τοποθεσία $i$ είναι $p_i$, $i = 1,
2, ..., n$. Σε κάθε τοποθεσία η αλυσίδα μπορεί να ανοίξει μόνο ένα εστιατόριο.
Επιπλέον, δύο εστιατόρια πρέπει να απέχουν μεταξύ τους τουλάχιστον $k$ μέτρα.
Χρησιμοποιώντας την μέθοδο του δυναμικού προγραμματισμού:
1. Περιγράψτε τα υποπροβλήματα και δώστε τον ψευδοκώδικα του αλγορίθμου που
   υπολογίζει το μέγιστο προσδοκώμενο συνολικό κέρδος.
2. Περιγράψτε γιατί αυτός ο αλγόριθμος είναι σωστός.
3. Αναλύστε το χρόνο εκτέλεσης του αλγορίθμου.

** Λογική ανάλυση προβλήματος 
Από την εκφώνηση της άσκησης θεωρούμε γνωστά στον αλγόριθμο τα:
- $n$: πλήθος τοποθεσιών
- $m$: πίνακας με όλες τις πιθανές θέσεις μαγαζιών, τοποθετημένα κατα αύξουσα σειρά
- $p$: πίνακας με το προσδοκώμενο /εισόδημα/ του μαγαζιού στην θέση $i$ της εγνατίας
- $k$: η ελάχιστη απόσταση μεταξύ δύο διαδοχικών στοιχείων του $m$

Το πρόβλημα ορίζεται ως εξής: Την εύρεση ενός συνόλου $n$ τοποθεσιών, /εφεξής
αναφερόμενες ως το σύνολο $Q_n$/, ούτως ώστε το συνολικό κέρδος, /εφεξής MP
"Maximum Profit"/, των εστιατορίων να μεγιστοποιείται, χωρίς όμως να καταπατάται
η συνθήκη εγγύτητας των εστιατορίων.

- *Συνθήκη εγγύτητας:*
  Για δύο διαδοχικές τοποθεσίες συνόλου $A \subseteq m$, $a_i,a_{i+1}$, πρέπει
  να ισχύει:
  \begin{equation}
  \label{eq:4}
  m[a_{i+1}] - m[a_i] \geq k
  \end{equation}

  Ορίζουμε το σύνολο υποσυνόλων του $m$ που ικανοποιούν την συνθήκη εγγύτητας $m_e$

- *Κέρδος συνόλου:*
  Ορίζουμε αρχικά την ιδιότητα $P$ "Profit", ενός συνόλου τοποθεσιών $A\subseteq m$,
  ως το άθροισμα των κερδών των επιμέρους τοποθεσιών: Αναλυτικότερα, για το σύνολο
  $A$ μήκους $n$ το $P$ ορίζεται ως εξής:
  \begin{equation}
  \label{eq:3}
  P_{A} = \sum_{i=1}^n p[a_{i}]
  \end{equation}

- *Υπο συνθήκη μεγιστοποίηση κέρδους συνόλου*: Βάση των προηγούμενων ορισμών
  ορίζουμε το $MP_{n}$ ως το κέρδος συνόλου $A \in m_{e}$ μήκους $n$ υπό την
  *απαραίτητη* προϋπόθεση ότι δεν υπάρχει υποσύνολο $B \in m_e$ μήκους $n$, του
  οποίου το κέρδος να είναι μεγαλύτερο.
  \begin{equation}
  \label{eq:2}
  MP_{n} = P_{A} \iff \nexists B\in m_e: P_B \geq P_{A}
  \end{equation}

  Ακόμα, στην περίπτωση που eqref:eq:2, τότε σημαίνει ότι έχουμε βρει το ζητούμενο
  σύνολο, για δεδομένη τιμή του $n$:
  \begin{equation}
  \label{eq:5}
  A = Q_n
  \end{equation}


** Αλγόριθμος
Βάση του ορισμού του προβλήματος, καθώς ζητάμε το $MP_n$, θα μπορούσαμε να
ακολουθήσουμε απλά την συλλογιστική διαδικασία που ακολουθήθηκε παραπάνω και ο
αλγόριθμος θα ήταν σίγουρα ορθός. Καθώς, όμως, περιλαμβανει τον υπολογισμό όλων
των υποσυνόλων του $m$ μήκους $n$ που ικανοποιούν την συνθήκη εγγύτητας ,
διαδικασία της τάξης $O(\binom{m.length!}{n!})$, είναι εμφανώς ο λάθος
αλγόριθμος να χρησιμοποιήσουμε.

Αντ' αυτού, μπορούμε να χρησιμοποιήσουμε την μέθοδο του δυναμικού
προγραμματισμού, ώστε να αποφύγουμε την επανάληψη εξέτασης των ίδιων υποσυνόλων
ξανά και ξανά:
#+begin_example
Εισόδημα(n, m, p, k):
    Δημιουργία πίνακα DP με μέγεθος (n + 1) x (m + 1)
    
    // Αρχικοποίηση
    Για i από 0 έως n:
        DP[i][0] = 0
    Για j από 0 έως m:
        DP[0][j] = 0
    
    // Υπολογισμός εισοδήματος χρησιμοποιώντας δυναμικό προγραμματισμό
    Για i από 1 έως n:
        Για j από 1 έως m:
            // Έλεγχος αν μπορεί να επιλεγεί η θέση m[j]
            Αν (m[j] - m[j-1] >= k):
                DP[i][j] = max(DP[i][j-1], p[m[j]] + DP[i-1][j-1])
            Αλλιώς:
                DP[i][j] = DP[i][j-1]
    
    Επιστροφή DP[n][m]
#+end_example


#+begin_src python
def rod_cutting_with_limit(n, price_table, max_cuts):
    # Create a table to store the maximum revenue for each subproblem
    revenue_table = [[0] * (max_cuts + 1) for _ in range(n + 1)]
  
    # Iterate over each length of the rod
    for i in range(1, n + 1):
        # Iterate over the maximum number of cuts allowed
        for j in range(1, max_cuts + 1):
            # Initialize the maximum revenue to be the revenue from not making any cuts
            max_revenue = revenue_table[i - 1][j]
          
            # Try making a cut at different positions and calculate the maximum revenue
            for k in range(1, i):
                # Calculate the revenue if a cut is made at position k
                revenue = price_table[k] + revenue_table[i - k - 1][j - 1]
              
                # Update the maximum revenue if the current cut gives a higher revenue
                max_revenue = max(max_revenue, revenue)
          
            # Store the maximum revenue in the table
            revenue_table[i][j] = max_revenue

    # Return the maximum revenue for the original problem
    return revenue_table[n][max_cuts]
#+end_src

** Χρονική ανάλυση
